# Set of valid operators for @test_sets
const OPS_SETCOMP = (
    :(==),
    :≠,
    :⊆, 
    :⊇, 
    :⊊, 
    :⊋,
    :∩,
)

# Additional valid operators that are converted in `preprocess`
const OPS_SETCOMP_CONVERTER = Dict(
    :!= => :≠,
    :⊂ => :⊆,
    :⊃ => :⊇,
    :|| => :∩,
    :issetequal => :(==),
    :isdisjoint => :∩,
    :issubset => :⊆,
)

#################### Pretty printing utilities ###################
const _INDENT_SETOP = "              "; # Match indentation of @test "Evaluated: " line

# ANSI color codes for pretty printing.
const LCOLOR = Ref{Symbol}(:cyan)
const RCOLOR = Ref{Symbol}(:magenta)

# Various internal utilities for color-printing expressions with "(L)" and "(R)".
function printL(
        io::IO, 
        L::AbstractString="L", 
        suffixes::AbstractString...
    ) 
    printstyled(io, L, color=LCOLOR[], bold=true)
    print(io, suffixes...)
end

function printR(
        io::IO, 
        R::AbstractString="R", 
        suffixes::AbstractString...
    )
    printstyled(io, R, color=RCOLOR[], bold=true)
    print(io, suffixes...)
end

function printLsepR(
        io::IO, 
        L::AbstractString, 
        sep::AbstractString, 
        R::AbstractString, 
        suffixes::AbstractString...;
        space::Bool = true
    ) 
    printL(io, L)
    space && print(io, " ")
    print(io, sep)
    space && print(io, " ")
    printR(io, R)
    print(io, suffixes...)
end

function printRsepL(
        io::IO, 
        R::AbstractString, 
        sep::AbstractString, 
        L::AbstractString,
        suffixes::AbstractString...;
        space::Bool = true
    )
    printR(io, R)
    space && print(io, " ")
    print(io, sep)
    space && print(io, " ")
    printL(io, L)
    print(io, suffixes...)
end

const LminusR = sprint(printLsepR, "L", "∖", "R", context = :color => false)
const RminusL = sprint(printRsepL, "R", "∖", "L", context = :color => false)
const LintersectR = sprint(printLsepR, "L", "∩", "R", context = :color => false)

# Print a set or vector compactly, with a description:
function printset(io::IO, v::Union{AbstractVector, AbstractSet}, desc::AbstractString)
    n = length(v)
    print(io, "\n", _INDENT_SETOP)
    print(io, desc)
    print(io, " has ", n, " element", n == 1 ? ":  " : "s: ")
    io_compact = IOContext(io, :compact => true, :limit => true, :typeinfo => typeof(v))
    Base.show_vector(io_compact, v)
end

# Stringify a processed `@test_sets` expression, to be printed in the `@test`
# `Evaluated: ` line.
function stringify_expr_test_sets(ex)
    suffix = ex.args[1] === :∩ ? " == ∅" : ""
    return sprint(printLsepR, 
                  string(ex.args[2]),
                  string(ex.args[1]),
                  string(ex.args[3]),
                  suffix, 
                  context = :color => true)
end


#################### Evaluating @test_sets ###################

# Internal function to process an expression `ex` for use in `@test_sets`. Validates
# the form `L <op> R` and convert any operator aliases to the canonical version.
function process_expr_test_sets(ex)

    # Special case in case someone uses `a ∩ b == ∅`
    if isexpr(ex, :call, 3) && ex.args[1] === :(==) 
        if isexpr(ex.args[2], :call, 3) && ex.args[2].args[1] === :∩ && ex.args[3] === :∅
            ex = ex.args[2]
        elseif isexpr(ex.args[3], :call, 3) && ex.args[3].args[1] === :∩ && ex.args[2] === :∅
            ex = ex.args[3]
        end
    end

    if isexpr(ex, :call, 3)
        op, L, R = ex.args
        op = get(OPS_SETCOMP_CONVERTER, op, op)
        if op ∉ OPS_SETCOMP
            error("invalid test macro call: @test_set unsupported set operator $op")
        end
    elseif isexpr(ex, :||, 2)
        op = :∩
        L, R = ex.args
    else
        error("invalid test macro call: @test_set $ex")
    end

    return Expr(:call, op, L, R)
end

# Internal function used at `@test_sets` runtime to get a `Returned` `Test.ExecutionResult`
# with nice failure messages. Used in the code generated by `get_test_sets_result()` at 
# compile time.
# - `L`: the container on the left side of the operator
# - `op`: the operator, one of `OPS_SETCOMP`
# - `R`: the container on the right side of the operator
function eval_test_sets(L, op, R, source)
    # Perform the desired set operation to get the boolean result:
    if op === :(==)
        res = issetequal(L, R)
    elseif op === :≠
        res = !issetequal(L, R)
    elseif op === :∩
        res = isdisjoint(L, R)
    else
        res = eval(op)(L, R)
    end

    # If the result is false, create a custom failure message depending on the operator:
    if res === false
        io = IOBuffer()
        ioc = IOContext(io, :color => true)

        if op === :(==) # issetequal(L, R)
            printLsepR(ioc, "L", "and", "R", " are not equal.")
            printset(ioc, setdiff(L, R), LminusR)
            printset(ioc, setdiff(R, L), RminusL)

        elseif op === :!= || op === :≠ # !issetequal(L, R)
            printLsepR(ioc, "L", "and", "R", " are equal.")

        elseif op === :⊆  # issubset(L, R)
            printLsepR(ioc, "L", "is not a subset of", "R", ".")
            printset(ioc, setdiff(L, R), LminusR)

        elseif op === :⊇ # issubset(R, L)
            printLsepR(ioc, "L", "is not a superset of", "R", ".")
            printset(ioc, setdiff(R, L), RminusL)

        elseif op === :⊊ && issetequal(L, R) # L ⊊ R (failure b/c not *proper* subset)
            printLsepR(ioc, "L", "is not a proper subset of", "R", ", it is equal.")

        elseif op === :⊊ # L ⊊ R (failure because L has extra elements)
            printLsepR(ioc, "L", "is not a proper subset of", "R", ".")
            printset(ioc, setdiff(L, R), LminusR)

        elseif op === :⊋ && issetequal(L, R) # L ⊋ R (failure b/c not *proper* superset)
            printLsepR(ioc, "L", "is not a proper superset of", "R", ", it is equal.")

        elseif op === :⊋ # L ⊋ R (failure because R has extra elements)
            printLsepR(ioc, "L", "is not a proper superset of", "R", ".")
            printset(ioc, setdiff(R, L), RminusL)

        elseif op === :∩ # isdisjoint(L, R)
            printLsepR(ioc, "L", "and", "R", " are not disjoint.")
            printset(ioc, intersect(L, R), LintersectR)

        else
            error("Unsupported operator $op.")
        end

        return Returned(res, String(take!(io)), source)

    else # res === true
        return Returned(res, nothing, source)
    end
end

# Internal function used at compile time to generate code that will produce the final
# `@test_sets` `Test.ExecutionResults`. Wraps `eval_test_sets()` in a try/catch block 
# so that exceptions can be returned as `Test.Threw` result.
function get_test_sets_result(ex, source)
    op, L, R = ex.args    
    if L === :∅ L = :(Set()) end
    if R === :∅ R = :(Set()) end
    
    result = quote
        try 
            eval_test_sets(
                $(esc(L)), 
                $(QuoteNode(op)),
                $(esc(R)), 
                $(QuoteNode(source))
            )
        catch _e
            _e isa InterruptException && rethrow()
            Threw(_e, Base.current_exceptions(), $(QuoteNode(source)))
        end
    end
    result
end

"""
    @test_sets L op R

Tests that the expression `L op R` returns `true`, where `op` is an *set comparison*
operator. `L` and `R` can be any iterable collection that supports set-like operations.

The following infix operators are supported:
- `==` tests that `issetequal(L, R)`
- `!=` or `≠` (`\\neq`) tests for `!issetequal(L, R)`
- `⊆` (`\\subseteq`) or `⊂` (`\\subset`) tests that `issubset(L, R)`
- `⊇` (`\\supseteq`) or `⊃` (`\\supset`) tests that `issubset(R, L)`
- `⊊` (`\\subsetneq`) tests that `issubset(L, R) && length(L) != length(R)`
- `⊋` (`\\supsetneq`) tests that `issubset(R, L) && length(L) != length(R)`
- `∩` (`\\cap`) or `||` tests that `isdisjoint(L, R)`

!!! note "∩ syntax"
    The last point represents a slight abuse of notation, in that disjointness is
    better notated as `L ∩ R == ∅`. The macro also supports this syntax, in addition 
    to shorthand `L ∩ R` and `L || R`.

# Examples 

```jldoctest; filter = r"(\\e\\[\\d+m|\\s+)"
julia> @test_sets Set([1,2]) == [2,1,1,1]
Test Passed

julia> @test_sets [2,5] ⊆ 1:10
Test Passed

julia> @test_sets [1,42] ⊆ 1:20
Test Failed at none:1
  Expression: [1, 42] ⊆ 1:20
   Evaluated: L is not a subset of R.
             L ∖ R has 1 element:  [42]

julia> @test_sets [2,1,1,2,3] == Set(2)
Test Failed at none:1
  Expression: [2, 1, 1, 2, 3] == Set(2)
   Evaluated: L and R are not equal.
              L ∖ R has 2 elements: [1, 3]
              R ∖ L has 0 elements: []

julia> @test_sets [1,2,3] ∩ [3,4,5]
Test Failed at none:1
  Expression: [1, 2, 3] ∩ [3, 4, 5] == ∅
   Evaluated: L and R are not disjoint.
              L ∩ R has 1 element:  [3]
```

The `∅` (`\\emptyset`) character can be used as shorthand for `Set()` in any set 
comparison:

```jldoctest; filter = r"(\\e\\[\\d+m|\\s+)"
julia> @test_sets Set() == ∅
Test Passed

julia> @test_sets [1,2,3] ≠ ∅
Test Passed
```

See also [`Base.issetequal`](@extref Julia), [`Base.issubset`](@extref Julia),
[`Base.isdisjoint`](@extref Julia).
"""
macro test_sets(ex, kws...)    
    # Collect the broken/skip keywords and remove them from the rest of keywords:
    kws, broken, skip = extract_broken_skip_keywords(kws...)

    # Ensure that no other expressions are present
    length(kws) == 0 || error("invalid test macro call: @test_sets $ex $(join(kws, " "))")
    
    # Process expression and get stringified version
    ex = process_expr_test_sets(ex)
    str_ex = stringify_expr_test_sets(ex)

    # Generate code to evaluate expression and return a `Test.ExecutionResult`
    result = get_test_sets_result(ex, __source__)

    result = quote
        if $(length(skip) > 0 && esc(skip[1]))
            record(get_testset(), Broken(:skipped, $str_ex))
        else
            let _do = $(length(broken) > 0 && esc(broken[1])) ? do_broken_test : do_test
                _do($result, $str_ex)
            end
        end
    end

end