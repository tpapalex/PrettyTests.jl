<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · PrettyTests.jl</title><meta name="title" content="Home · PrettyTests.jl"/><meta property="og:title" content="Home · PrettyTests.jl"/><meta property="twitter:title" content="Home · PrettyTests.jl"/><meta name="description" content="Documentation for PrettyTests.jl."/><meta property="og:description" content="Documentation for PrettyTests.jl."/><meta property="twitter:description" content="Documentation for PrettyTests.jl."/><meta property="og:url" content="https://tpapalex.github.io/PrettyTests.jl/"/><meta property="twitter:url" content="https://tpapalex.github.io/PrettyTests.jl/"/><link rel="canonical" href="https://tpapalex.github.io/PrettyTests.jl/"/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>PrettyTests.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#@test_sets-for-set-like-comparisons"><span><code>@test_sets</code> for set-like comparisons</span></a></li><li><a class="tocitem" href="#@test_all-for-vectorized-tests"><span><code>@test_all</code> for vectorized tests</span></a></li><li><a class="tocitem" href="#Test-integrations"><span><code>Test</code> integrations</span></a></li></ul></li><li><a class="tocitem" href="reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/tpapalex/PrettyTests.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/tpapalex/PrettyTests.jl/blob/dev/docs/src/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Home"><a class="docs-heading-anchor" href="#Home">Home</a><a id="Home-1"></a><a class="docs-heading-anchor-permalink" href="#Home" title="Permalink"></a></h1><p>This <a href="https://github.com/tpapalex/PrettyTests.jl">PrettyTests</a> package extends Julia&#39;s basic unit-testing functionality by providing drop-in replacements for <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.%40test"><code>Test.@test</code></a> with more informative, human-readable failure messages.</p><ul><li><a href="#@test_sets-for-set-like-comparisons"><code>@test_sets</code> for set-like comparisons</a></li><li class="no-marker"><ul><li><a href="#Set-equality">Set equality</a></li><li><a href="#Other-operators">Other operators</a></li></ul></li><li><a href="#@test_all-for-vectorized-tests"><code>@test_all</code> for vectorized tests</a></li><li class="no-marker"><ul><li><a href="#Basic-usage">Basic usage</a></li><li><a href="#Broadcasting-behavior">Broadcasting behavior</a></li><li><a href="#Keyword-splicing">Keyword splicing</a></li><li><a href="#General-iterables">General iterables</a></li><li><a href="#Missing-values"><code>Missing</code> values</a></li><li><a href="#Non-Boolean-values">Non-Boolean values</a></li></ul></li><li><a href="#Test-integrations"><code>Test</code> integrations</a></li><li class="no-marker"><ul><li><a href="#Broken/skipped-tests">Broken/skipped tests</a></li><li><a href="#Working-with-@testset">Working with <code>@testset</code></a></li></ul></li></ul><h2 id="@test_sets-for-set-like-comparisons"><a class="docs-heading-anchor" href="#@test_sets-for-set-like-comparisons"><code>@test_sets</code> for set-like comparisons</a><a id="@test_sets-for-set-like-comparisons-1"></a><a class="docs-heading-anchor-permalink" href="#@test_sets-for-set-like-comparisons" title="Permalink"></a></h2><h3 id="Set-equality"><a class="docs-heading-anchor" href="#Set-equality">Set equality</a><a id="Set-equality-1"></a><a class="docs-heading-anchor-permalink" href="#Set-equality" title="Permalink"></a></h3><p>The <a href="reference/#PrettyTests.@test_sets"><code>@test_sets</code></a> macro functions as a drop-in replacement for <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.%40test"><code>@test</code></a> when comparing two set-like objects. It accepts expressions of the form <code>@test_sets L &lt;op&gt; R</code> where <code>op</code> is an infix set comparison operator, and <code>L</code> and <code>R</code> are collections, broadly defined.</p><p>In the simplest example, one could test for set equality with the (overloaded) <code>==</code> operator:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a, b = [2, 1, 1], [1, 2];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets a == b</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><p>This is equivalent to the uglier test <code>@test issetequal(a, b)</code>. It is also more informative in the case of failure:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets a == 2:4</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[1]:2</span>
  Expression: <span class="sgr96">a</span> == <span class="sgr95">2:4</span>
   Evaluated: <span class="sgr96">L</span> and <span class="sgr95">R</span> are not equal.
              L ∖ R has 1 element:  [1]
              R ∖ L has 2 elements: [3, 4]</code></pre><p>The failed test message lists exactly how many and which elements were in the set differences <code>L \ R</code> and <code>R \ L</code>, which should have been empty in a passing test.</p><p>Note how the collections interpreted as <code>L</code> and <code>R</code> are color-coded, so that they can be more easily identified if the expressions are long:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; variable_with_long_name = 1:3;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; function_with_long_name = () -&gt; 4:9;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets variable_with_long_name ∪ Set(4:6) == function_with_long_name()</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[3]:2</span>
  Expression: <span class="sgr96">variable_with_long_name ∪ Set(4:6)</span> == <span class="sgr95">function_with_long_name()</span>
   Evaluated: <span class="sgr96">L</span> and <span class="sgr95">R</span> are not equal.
              L ∖ R has 3 elements: [1, 2, 3]
              R ∖ L has 3 elements: [7, 8, 9]</code></pre><div class="admonition is-info"><header class="admonition-header">Disable color output</header><div class="admonition-body"><p>To disable colored subexpressions in failure messages use <a href="reference/#PrettyTests.disable_failure_styling"><code>disable_failure_styling()</code></a>.</p></div></div><p>The symbol <code>∅</code> can be used as shorthand for <code>Set()</code> in the place of either <code>L</code> or <code>R</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets Set() == ∅</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets Set(1) == ∅</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[2]:2</span>
  Expression: <span class="sgr96">Set(1)</span> == <span class="sgr95">∅</span>
   Evaluated: <span class="sgr96">L</span> and <span class="sgr95">R</span> are not equal.
              L ∖ R has 1 element:  [1]
              R ∖ L has 0 elements: []</code></pre><p>Because the macro internally expands the input expression to an <a href="https://docs.julialang.org/en/v1/base/collections/#Base.issetequal"><code>issetequal</code></a> call (and uses <a href="https://docs.julialang.org/en/v1/base/collections/#Base.setdiff"><code>setdiff</code></a> to print the differences), it works very flexibly with general collections, including sets, dictionaries, strings, etc:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets Dict() == Set()</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets &quot;baabaa&quot; == &quot;abc&quot;</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[2]:2</span>
  Expression: <span class="sgr96">&quot;baabaa&quot;</span> == <span class="sgr95">&quot;abc&quot;</span>
   Evaluated: <span class="sgr96">L</span> and <span class="sgr95">R</span> are not equal.
              L ∖ R has 0 elements: []
              R ∖ L has 1 element:  [&#39;c&#39;]</code></pre><h3 id="Other-operators"><a class="docs-heading-anchor" href="#Other-operators">Other operators</a><a id="Other-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Other-operators" title="Permalink"></a></h3><p>Other set comparison tests are also supported, with tailored failure messages. For example, the expression <code>L ⊆ R</code> is equivalent to <code>issubset(L, R)</code> <a href="https://docs.julialang.org/en/v1/base/collections/#Base.issubset">(as it is in base Julia)</a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets &quot;baabaa&quot; ⊆ &quot;abc&quot;</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets (3, 1, 2, 3) ⊆ (1, 2)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[2]:2</span>
  Expression: <span class="sgr96">(3, 1, 2, 3)</span> ⊆ <span class="sgr95">(1, 2)</span>
   Evaluated: <span class="sgr96">L</span> is not a subset of <span class="sgr95">R</span>.
              L ∖ R has 1 element:  [3]</code></pre><p>Note how, in this case, the failure displays only the set difference <code>L \ R</code> and omits the irrelevant <code>R \ L</code>.</p><p>The form <code>L ∩ R == ∅</code> is equivalent to <a href="https://docs.julialang.org/en/v1/base/collections/#Base.isdisjoint"><code>isdisjoint</code></a><code>(L, R)</code>. In the case of failure, the macro displays the non-empty intersection <code>L ∩ R</code>, as computed by <a href="https://docs.julialang.org/en/v1/base/collections/#Base.intersect">intersect</a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets (1, 2, 3) ∩ (4, 5, 6) == ∅</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets &quot;baabaa&quot; ∩ &quot;abc&quot; == ∅</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[2]:2</span>
  Expression: <span class="sgr96">&quot;baabaa&quot;</span> ∩ <span class="sgr95">&quot;abc&quot;</span> == ∅
   Evaluated: <span class="sgr96">L</span> and <span class="sgr95">R</span> are not disjoint.
              L ∩ R has 2 elements: [&#39;b&#39;, &#39;a&#39;]</code></pre><div class="admonition is-info"><header class="admonition-header">Shorthand disjointness syntax</header><div class="admonition-body"><p>Though slightly abusive in terms of notation, the macro will also accept <code>L ∩ R</code> and <code>L || R</code> as shorthands for <code>isdisjoint(L, R)</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets &quot;baabaa&quot; ∩ &quot;moooo&quot;</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets (1,2) || (3,4)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre></div></div><h2 id="@test_all-for-vectorized-tests"><a class="docs-heading-anchor" href="#@test_all-for-vectorized-tests"><code>@test_all</code> for vectorized tests</a><a id="@test_all-for-vectorized-tests-1"></a><a class="docs-heading-anchor-permalink" href="#@test_all-for-vectorized-tests" title="Permalink"></a></h2><h3 id="Basic-usage"><a class="docs-heading-anchor" href="#Basic-usage">Basic usage</a><a id="Basic-usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-usage" title="Permalink"></a></h3><p>The <a href="reference/#PrettyTests.@test_all"><code>@test_all</code></a> macro functions as a drop-in replacement for &quot;vectorized&quot; <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.%40test"><code>@test</code></a>s. The name derives from the fact that <code>@test_all ex</code> will (mostly) behave like <code>@test all(ex)</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; a = [1, 2, 3, 4];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test all(a .&lt; 5)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all a .&lt; 5</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr32"><span class="sgr1">Test Passed</span></span></code></pre><p>With one important difference: <code>@test_all</code> does not <a href="https://docs.julialang.org/en/v1/base/collections/#Base.all-Tuple%7BAny%7D">short-circuit</a> when it encounters the first <code>false</code> value. It evaluates the full expression and checks that <em>each element</em> is not <code>false</code>, printing errors for each &quot;individual&quot; failure:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all a .&lt; 2</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[1]:2</span>
  Expression: all(<span class="sgr96">a</span> .&lt; <span class="sgr95">2</span>)
   Evaluated: false
    Argument: 4-element BitVector, 3 failures: 
              [2]: <span class="sgr96">2</span> &lt; <span class="sgr95">2</span><span class="sgr93"> ===&gt; false</span>
              [3]: <span class="sgr96">3</span> &lt; <span class="sgr95">2</span><span class="sgr93"> ===&gt; false</span>
              [4]: <span class="sgr96">4</span> &lt; <span class="sgr95">2</span><span class="sgr93"> ===&gt; false</span></code></pre><p>The failure message can be parsed as follows:</p><ul><li>The expression <code>all(a .&lt; 2)</code> evaluated to <code>false</code></li><li>The argument to <code>all()</code> was a <code>4-element BitVector</code></li><li>There were <code>3</code> failures, i.e. elements of the argument that were <code>false</code></li><li>These occured at indices <code>[2]</code>, <code>[3]</code> and <code>[4]</code></li></ul><p>Like <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.%40test"><code>@test</code></a>, the macro performed some introspection to show an <em>unvectorized</em> (and color-coded) form of the expression for each individual failure. For example, the failure at index <code>[4]</code> was because <code>a[4] = 4</code>, and <code>4 &lt; 2</code> evaluated to <code>false</code>.</p><p>The introspection goes quite a bit deeper than what <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.%40test"><code>@test</code></a> supports, handling pretty complicated expressions:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x, y, str, func = 2, 4.0, &quot;baa&quot;, arg -&gt; arg &gt; 0;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all (x .&lt; 2) .| isnan.(y) .&amp; .!occursin.(r&quot;a|b&quot;, str) .| func(-1)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[2]:2</span>
  Expression: all((<span class="sgr96">x</span> .&lt; <span class="sgr95">2</span>) .| isnan.(<span class="sgr94">y</span>) .&amp; .!occursin.(<span class="sgr92">r&quot;a|b&quot;</span>, <span class="sgr96">str</span>) .| <span class="sgr95">func(-1)</span>)
   Evaluated: false
    Argument: (<span class="sgr96">2</span> &lt; <span class="sgr95">2</span>) | isnan(<span class="sgr94">4.0</span>) &amp; !occursin(<span class="sgr92">r&quot;a|b&quot;</span>, <span class="sgr96">&quot;baa&quot;</span>) | <span class="sgr95">false</span><span class="sgr93"> ===&gt; false</span></code></pre><p>Note also how, since <code>ex</code> evaluated to a scalar in this case, the failure message ommitted the summary/indexing and printed just the single failure under <code>Argument:</code>.</p><div class="admonition is-info"><header class="admonition-header">Disable color output</header><div class="admonition-body"><p>To disable colored subexpressions in failure messages use <a href="reference/#PrettyTests.disable_failure_styling"><code>disable_failure_styling()</code></a>.</p></div></div><div class="admonition is-info"><header class="admonition-header">Why not `@testset` for ...?</header><div class="admonition-body"><p>One could achieve a similar effect to <code>@test_all</code> by using the <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.%40testset"><code>@testset for</code></a> built in to <a href="https://docs.julialang.org/en/v1/stdlib/Test/"><code>Test</code></a>.  The test <code>@test_all a .&lt; 2</code> is basically equivalent to:</p><pre><code class="language- hljs">@testset for i in eachindex(a)
    @test a[i] &lt; 2
end</code></pre><p>While this syntax is more general, in cases where either form could be used <code>@test_all</code> offers some advantages:</p><ul><li>More compact syntax: obviates the need for the <code>@testset for</code> wrapper, as well as explicit indexing (e.g. <code>a[i]</code>) that can be left to broadcasting semantics.</li><li>More compact failure messaging: all relevant information about the indices and failure modes is given in a single <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.Fail"><code>Test.Fail</code></a> result,  reducing redundant messages and print-outs from nested test sets.</li><li>Better readability: Deeper introspection and color-coding makes for more readable messages (see above).</li></ul></div></div><h3 id="Broadcasting-behavior"><a class="docs-heading-anchor" href="#Broadcasting-behavior">Broadcasting behavior</a><a id="Broadcasting-behavior-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting-behavior" title="Permalink"></a></h3><p>Expressions that involve more complicated broadcasting behaviour are also nicely formatted. If the expression evaluates to a higher-dimensional array (e.g. matrix), individual failures are identified by their <a href="https://docs.julialang.org/en/v1/manual/arrays/#Cartesian-indices"><code>CartesianIndex</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all [1 0] .== [1 0; 0 1]</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[1]:2</span>
  Expression: all(<span class="sgr96">[1 0]</span> .== <span class="sgr95">[1 0; 0 1]</span>)
   Evaluated: false
    Argument: 2×2 BitMatrix, 2 failures: 
              [2,1]: <span class="sgr96">1</span> == <span class="sgr95">0</span><span class="sgr93"> ===&gt; false</span>
              [2,2]: <span class="sgr96">0</span> == <span class="sgr95">1</span><span class="sgr93"> ===&gt; false</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all occursin.([r&quot;a|b&quot; &quot;oo&quot;], [&quot;moo&quot;, &quot;baa&quot;])</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[2]:2</span>
  Expression: all(occursin.(<span class="sgr96">[r&quot;a|b&quot; &quot;oo&quot;]</span>, <span class="sgr95">[&quot;moo&quot;, &quot;baa&quot;]</span>))
   Evaluated: false
    Argument: 2×2 BitMatrix, 2 failures: 
              [1,1]: occursin(<span class="sgr96">r&quot;a|b&quot;</span>, <span class="sgr95">&quot;moo&quot;</span>)<span class="sgr93"> ===&gt; false</span>
              [2,2]: occursin(<span class="sgr96">&quot;oo&quot;</span>, <span class="sgr95">&quot;baa&quot;</span>)<span class="sgr93"> ===&gt; false</span></code></pre><p><code>Ref</code> can be used to avoid broadcasting certain elements:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; vals = [1,2,3];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all 1:5 .∈ Ref(vals)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[2]:2</span>
  Expression: all(<span class="sgr96">1:5</span> .∈ <span class="sgr95">Ref(vals)</span>)
   Evaluated: false
    Argument: 5-element BitVector, 2 failures: 
              [4]: <span class="sgr96">4</span> ∈ <span class="sgr95">[1, 2, 3]</span><span class="sgr93"> ===&gt; false</span>
              [5]: <span class="sgr96">5</span> ∈ <span class="sgr95">[1, 2, 3]</span><span class="sgr93"> ===&gt; false</span></code></pre><details class="admonition is-details"><summary class="admonition-header">Introspection mechanics</summary><div class="admonition-body"><p>To create individual failure messages, the <code>@test_all</code> parser recursively dives through the <a href="https://docs.julialang.org/en/v1/devdocs/ast/#Surface-syntax-AST">Abstract Syntax Tree (AST)</a> of the input expression and creates/combines <a href="https://github.com/JuliaString/Format.jl"><code>python</code>-like format strings</a> for any of the following &quot;displayable&quot; forms:</p><ul><li><code>:comparison</code>s or <code>:call</code>s with vectorized comparison operators, e.g. <code>.==</code>, <code>.≈</code>, <code>.∈</code>, etc.</li><li><code>:call</code>s to the vectorized negation operator <code>.!</code></li><li><code>:call</code>s to vectorized bitwise logical operators, e.g. <code>.&amp;</code>, <code>.|</code>, <code>.⊻</code>, <code>.⊽</code></li><li><code>:.</code> (broadcast dot) calls to certain common functions, e.g. <code>isnan</code>, <code>contains</code>, <code>occursin</code>, etc.</li></ul><p>Any (sub-)expressions that do not fall into one of these categories are escaped and collectively <a href="https://docs.julialang.org/en/v1/base/arrays/#Base.Broadcast.broadcast"><code>broadcast</code></a>, so that elements can splatted into the format string at each failing index.</p><p><em>Note:</em> Unvectorized forms are not considered displayable by the parser.  This is to avoid certain ambiguities with broadcasting under the current implementation. This may be changed in future.</p><h5>Example 1</h5><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x, y = 2, 1;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all (x .&lt; y) .&amp; (x &lt; y)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[2]:2</span>
  Expression: all((<span class="sgr96">x</span> .&lt; <span class="sgr95">y</span>) .&amp; (<span class="sgr94">x &lt; y</span>))
   Evaluated: false
    Argument: (<span class="sgr96">2</span> &lt; <span class="sgr95">1</span>) &amp; <span class="sgr94">false</span><span class="sgr93"> ===&gt; false</span></code></pre><p>In this example, the parser first receives the top-level expression <code>(x .&lt; y) .&amp; (x &lt; y)</code>, which it knows to display as <code>$f1 &amp; $f2</code> in unvectorized form.  The sub-format strings <code>f1</code> and <code>f2</code> must then be determined by recursively parsing  the expressions on either side of <code>.&amp;</code>. </p><p>On the left side, the sub-expression <code>x .&lt; y</code> is also displayable as <code>($f11 &lt; $f12)</code> with format strings <code>f11</code> and <code>f22</code> given by further recursion. At this level, the  parser hits the base case, since neither <code>x</code> nor <code>y</code> are displayable forms. The two expressions are escaped and used as the first and second broadcast arguments, while the corresponding format strings <code>{1:s}</code> and <code>{2:s}</code> are passed back up the recursion to create <code>f1</code> as <code>({1:s} &lt; {2:s})</code>.</p><p>On the right side, <code>x &lt; y</code> is <em>not</em> displayable (since it is unvectorized) and  therefore escaped as whole to make the third broadcasted argument. The corresponding format string <code>{3:s}</code> is passed back up the recursion, and used as <code>f2</code>.</p><p>By the end, the parser has created the format string is <code>({1:s} &lt; {2:s}) &amp; {3:s}</code>,  with three corresponding expressions <code>x</code>, <code>y</code>, and <code>x &lt; y</code>. Evaluating and collectively  broadcasting the latter results in the scalar 3-tuple <code>(2, 1, false)</code>, which matches the dimension of the evaluated expression (<code>false</code>). Since this is a failure, the 3-tuple is splatted into the format string to create the part of the message that reads <code>(2 &lt; 1) &amp; false</code>.</p><h5>Example 2</h5><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; x, y = [5 6; 7 8], [5 6];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all x .== y</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[2]:2</span>
  Expression: all(<span class="sgr96">x</span> .== <span class="sgr95">y</span>)
   Evaluated: false
    Argument: 2×2 BitMatrix, 2 failures: 
              [2,1]: <span class="sgr96">7</span> == <span class="sgr95">5</span><span class="sgr93"> ===&gt; false</span>
              [2,2]: <span class="sgr96">8</span> == <span class="sgr95">6</span><span class="sgr93"> ===&gt; false</span></code></pre><p>Here, the top-level expression <code>x .== y</code> is displayable, while the two sub-expressions <code>x</code> and <code>y</code> are not. The parser creates a format string <code>{1:s} == {2:s}</code> with  corresponding expressions <code>x</code> and <code>y</code>. </p><p>After evaluating and broadcasting, the arguments create a <code>2×2</code> matrix of 2-tuples  to go with the <code>2×2 BitMatrix</code> result. The latter has two <code>false</code> elements at indices <code>[2,1]</code> and <code>[2,2]</code>, corresponding to the 2-tuples <code>(7, 5)</code> and <code>(8, 6)</code>. Splatting each of these into the format string creates the parts of the message that read  <code>7 == 5</code> and <code>8 == 6</code>.</p></div></details><h3 id="Keyword-splicing"><a class="docs-heading-anchor" href="#Keyword-splicing">Keyword splicing</a><a id="Keyword-splicing-1"></a><a class="docs-heading-anchor-permalink" href="#Keyword-splicing" title="Permalink"></a></h3><p>Like <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.%40test"><code>@test</code></a>, <a href="reference/#PrettyTests.@test_all"><code>@test_all</code></a> will accept trailing keyword arguments that will be spliced into <code>ex</code> if it is a function call (possibly vectorized). This is primarily useful to make vectorized approximate comparisons more readable:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; v = [3, π, 4];</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all v .≈ 3.14 atol=0.01</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[2]:2</span>
  Expression: all(.≈(<span class="sgr96">v</span>, <span class="sgr95">3.14</span>, atol=<span class="sgr94">0.01</span>))
   Evaluated: false
    Argument: 3-element BitVector, 2 failures: 
              [1]: <span class="sgr96">3.0</span> ≈ <span class="sgr95">3.14</span> (atol=<span class="sgr94">0.01</span>)<span class="sgr93"> ===&gt; false</span>
              [3]: <span class="sgr96">4.0</span> ≈ <span class="sgr95">3.14</span> (atol=<span class="sgr94">0.01</span>)<span class="sgr93"> ===&gt; false</span></code></pre><p>As shown in the <code>Expression:</code> section, the trailing keyword <code>atol</code> was added to the <code>.≈</code> call resulting in the test <code>all(.≈(v, 3.14, atol=0.01))</code>.</p><p>Splicing works with any callable function, including if it is wrapped in a negation:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; ismod0 = (x; p=2) -&gt; x % p == 0;</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all .!ismod0.(1:3) p = 3</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[2]:2</span>
  Expression: all(.!<span class="sgr96">ismod0.(1:3, p = 3)</span>)
   Evaluated: false
    Argument: 3-element BitVector, 1 failure: 
              [3]: !<span class="sgr96">true</span><span class="sgr93"> ===&gt; false</span></code></pre><h3 id="General-iterables"><a class="docs-heading-anchor" href="#General-iterables">General iterables</a><a id="General-iterables-1"></a><a class="docs-heading-anchor-permalink" href="#General-iterables" title="Permalink"></a></h3><p>Paralleling its <a href="https://docs.julialang.org/en/v1/base/collections/#Base.all-Tuple%7BAny%7D">namesake</a>, <a href="reference/#PrettyTests.@test_all"><code>@test_all</code></a> works with general iterables (as long as they also define <a href="https://docs.julialang.org/en/v1/base/collections/#Base.length"><code>length</code></a>):</p><pre><code class="language-julia hljs">struct IsEven vals end
Base.iterate(x::IsEven, i=1) = i &gt; length(x.vals) ? nothing : (iseven(x.vals[i]), i+1);
Base.length(x::IsEven) = length(x.vals)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all IsEven(1:4)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[1]:2</span>
  Expression: all(<span class="sgr96">IsEven(1:4)</span>)
   Evaluated: false
    Argument: IsEven, 2 failures</code></pre><p>If they also define <a href="https://docs.julialang.org/en/v1/base/collections/#Base.keys"><code>keys</code></a> and a corresponding <a href="https://docs.julialang.org/en/v1/base/collections/#Base.getindex"><code>getindex</code></a>, failures will be printed by index:</p><pre><code class="language-julia hljs">Base.keys(x::IsEven) = keys(x.vals)
Base.getindex(x::IsEven, args...) = getindex(x.vals, args...)</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all IsEven(1:4)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[1]:2</span>
  Expression: all(<span class="sgr96">IsEven(1:4)</span>)
   Evaluated: false
    Argument: IsEven, 2 failures: 
              [1]: <span class="sgr96">false</span><span class="sgr93"> ===&gt; 1</span>
              [3]: <span class="sgr96">false</span><span class="sgr93"> ===&gt; 3</span></code></pre><div class="admonition is-warning"><header class="admonition-header">Short-circuiting and iterables</header><div class="admonition-body"><p>Since <code>@test_all ex</code> does not short-circuit at the first <code>false</code> value, it may behave differently than <code>@test all(ex)</code> in certain edge cases, notably when iterating over <code>ex</code> has side-effects.</p><p>Consider the same <code>IsEven</code> iterable as above, but with an assertion that each value is non-negative:</p><pre><code class="language-julia hljs">function Base.iterate(x::IsEven, i=1)
    i &gt; length(x.vals) &amp;&amp; return nothing
    @assert x.vals[i] &gt;= 0
    iseven(x.vals[i]), i+1
end
x = IsEven([1, 0, -1])</code></pre><p>Evaluating <code>@test all(x)</code> will return a <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.Fail"><code>Test.Fail</code></a>, since the  evaluation of <code>all(x)</code> short-circuits after the first iteration and returns <code>false</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test all(x)</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[1]:2</span>
  Expression: all(x)</code></pre><p>Conversely, <code>@test_all x</code> will return a <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.Error"><code>Test.Error</code></a> because it evaluates all iterations and thus triggers the assertion error on the third iteration:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all x</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Error During Test</span></span> at <span class="sgr1">REPL[1]:2</span>
  Test threw exception
  Expression: all(<span class="sgr96">x</span>)
  AssertionError: x.vals[i] &gt;= 0
  Stacktrace: [...]</code></pre></div></div><h3 id="Missing-values"><a class="docs-heading-anchor" href="#Missing-values"><code>Missing</code> values</a><a id="Missing-values-1"></a><a class="docs-heading-anchor-permalink" href="#Missing-values" title="Permalink"></a></h3><p>The only other major difference between <code>@test all(ex)</code> and <code>@test_all ex</code> is in how they deal with missing values. Recall that, in the presence of missing values, <a href="https://docs.julialang.org/en/v1/base/collections/#Base.all-Tuple%7BAny%7D"><code>all()</code></a> will return <code>false</code> if any non-missing value is <code>false</code>, or <code>missing</code> if all non-missing values are <code>true</code>.</p><p>Within an <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.%40test"><code>@test</code></a>, the former will return a <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.Fail"><code>Test.Fail</code></a> result, whereas the latter a <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.Error"><code>Test.Error</code></a>, pointing out that the return value was non-Boolean:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test all([1, missing] .== 2) # [false, missing] ===&gt; false</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[1]:2</span>
  Expression: all([1, missing] .== 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test all([2, missing] .== 2) # [true, missing] ===&gt; missing</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Error During Test</span></span> at <span class="sgr1">REPL[2]:2</span>
  Expression evaluated to non-Boolean
  Expression: all([2, missing] .== 2)
       Value: missing</code></pre><p>In the respective cases, <a href="reference/#PrettyTests.@test_all"><code>@test_all</code></a> will show the result of evaluating <code>all(ex)</code> (<code>false</code> or <code>missing</code>), but always returns a <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.Fail"><code>Test.Fail</code></a> result showing individual elements that were <code>missing</code> along with the ones that were <code>false</code>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all [1, missing] .== 2</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[1]:2</span>
  Expression: all(<span class="sgr96">[1, missing]</span> .== <span class="sgr95">2</span>)
   Evaluated: false
    Argument: 2-element Vector{Union{Missing, Bool}}, 1 missing and 1 failure: 
              [1]: <span class="sgr96">1</span> == <span class="sgr95">2</span><span class="sgr93"> ===&gt; false</span>
              [2]: <span class="sgr96">missing</span> == <span class="sgr95">2</span><span class="sgr93"> ===&gt; missing</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all [2, missing] .== 2</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Test Failed</span></span> at <span class="sgr1">REPL[2]:2</span>
  Expression: all(<span class="sgr96">[2, missing]</span> .== <span class="sgr95">2</span>)
   Evaluated: missing
    Argument: 2-element Vector{Union{Missing, Bool}}, 1 missing: 
              [2]: <span class="sgr96">missing</span> == <span class="sgr95">2</span><span class="sgr93"> ===&gt; missing</span></code></pre><h3 id="Non-Boolean-values"><a class="docs-heading-anchor" href="#Non-Boolean-values">Non-Boolean values</a><a id="Non-Boolean-values-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Boolean-values" title="Permalink"></a></h3><p>Finally, the macro will also produce a customized <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.Error"><code>Test.Error</code></a> result if the evaluated argument contains any non-Boolean, non-missing values. Where <code>all()</code> would short-circuit and throw a <a href="https://docs.julialang.org/en/v1/base/base/#Core.TypeError"><code>Core.TypeError</code></a> on the first non-Boolean value, <a href="reference/#PrettyTests.@test_all"><code>@test_all</code></a> identifies the indices of <em>all</em> non-Boolean, non-missing values:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all [true, false, 42, &quot;a&quot;, missing]</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Error During Test</span></span> at <span class="sgr1">REPL[1]:2</span>
  Test threw exception
  Expression: all(<span class="sgr96">[true, false, 42, &quot;a&quot;, missing]</span>)
   TypeError: non-boolean used in boolean context
    Argument: 5-element Vector{Any} with 2 non-Boolean values:
              [3]: 42<span class="sgr93"> ===&gt; Int64</span>
              [4]: &quot;a&quot;<span class="sgr93"> ===&gt; String</span>
  Stacktrace: [...]</code></pre><h2 id="Test-integrations"><a class="docs-heading-anchor" href="#Test-integrations"><code>Test</code> integrations</a><a id="Test-integrations-1"></a><a class="docs-heading-anchor-permalink" href="#Test-integrations" title="Permalink"></a></h2><p>A core feature of <code>PrettyTests</code> is that its macros integrate seamlessly with Julia&#39;s standard <a href="https://docs.julialang.org/en/v1/stdlib/Test/">unit-testing framework</a>. This stems primarily from the fact that they return one of the standard <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.Result"><code>Test.Result</code></a> objects defined therein, namely:</p><ul><li><a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.Pass"><code>Test.Pass</code></a> if the test expression evaluates to <code>true</code></li><li><a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.Fail"><code>Test.Fail</code></a> if it evaluates to <code>false</code> (or <code>missing</code> in the case of <code>@test_all</code>)</li><li><a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.Error"><code>Test.Error</code></a> if it cannot be evaluated.</li><li><a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.Broken"><code>Test.Broken</code></a> if the test is marked as broken.</li></ul><h3 id="Broken/skipped-tests"><a class="docs-heading-anchor" href="#Broken/skipped-tests">Broken/skipped tests</a><a id="Broken/skipped-tests-1"></a><a class="docs-heading-anchor-permalink" href="#Broken/skipped-tests" title="Permalink"></a></h3><p>Both macros provide support for <code>skip</code> and <code>broken</code> keywords, with similar behavior to <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.%40test"><code>@test</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_sets 1 ⊆ 2 skip=true</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr33"><span class="sgr1">Test Broken</span></span>
  Skipped: <span class="sgr96">1</span> ⊆ <span class="sgr95">2</span></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all 1 .== 2 broken=true</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr33"><span class="sgr1">Test Broken</span></span>
  Expression: all(<span class="sgr96">1</span> .== <span class="sgr95">2</span>)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @test_all 1 .== 1 broken=true</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr91"><span class="sgr1">Error During Test</span></span> at <span class="sgr1">REPL[3]:2</span>
 Unexpected Pass
 Expression: all(<span class="sgr96">1</span> .== <span class="sgr95">1</span>)
 Got correct result, please change to @test if no longer broken.</code></pre><h3 id="Working-with-@testset"><a class="docs-heading-anchor" href="#Working-with-@testset">Working with <code>@testset</code></a><a id="Working-with-@testset-1"></a><a class="docs-heading-anchor-permalink" href="#Working-with-@testset" title="Permalink"></a></h3><p>The macros also automatically run <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.record"><code>Test.record(</code></a><a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.get_testset"><code>Test.get_testset()</code></a><a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.record"><code>, result)</code></a> so that they play nicely with both built-in and user-defined <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Creating-Custom-AbstractTestSet-Types"><code>AbstractTestSet</code></a> types. In particular, they will register inside an <a href="https://docs.julialang.org/en/v1/stdlib/Test/#Test.%40testset"><code>@testset</code></a>:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @testset &quot;MyTestSet&quot; begin
           a = [1, 2]
           @test_all a .== 1:2
           @test_all a .&lt; 1:2 broken=true
           @test_sets a ⊆ 1:2
           @test_sets a == 1:3 skip=true
       end;</code><code class="nohighlight hljs ansi" style="display:block;"><span class="sgr1">Test Summary: | <span class="sgr32">Pass  </span><span class="sgr33">Broken  </span><span class="sgr36">Total  </span>Time</span>
MyTestSet     | <span class="sgr32">   2  </span><span class="sgr33">     2  </span><span class="sgr36">    4  </span>0.5s</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Wednesday 22 May 2024 22:43">Wednesday 22 May 2024</span>. Using Julia version 1.10.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
