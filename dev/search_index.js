var documenterSearchIndex = {"docs":
[{"location":"reference/#Macros","page":"Reference","title":"Macros","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"PrettyTests.@test_sets\nPrettyTests.@test_all","category":"page"},{"location":"reference/#PrettyTests.@test_sets","page":"Reference","title":"PrettyTests.@test_sets","text":"@test_sets L op R\n@test_sets L op R broken=true\n@test_sets L op R skip=true\n\nTest that the expression L op R evaluates to true, where op is an infix operator interpreted as a set-like comparison:\n\nL == R expands to issetequal(L, R)\nL != R or L ≠ R expands to !issetequal(L, R)\nL ⊆ R or L ⊂ R expands to ⊆(L, R)\nL ⊇ R or L ⊃ R expands to ⊇(L, R)\nL ⊊ R expands to ⊊(L, R)\nL ⊋ R expands to ⊋(L, R)\nL ∩ R or L || R expands to isdisjoint(L, R)\n\nIf executed inside a Test.@testset, return a Test.Pass result if the expanded expression evaluates to true, a  Test.Fail result if it is false, and an Test.Error result if it could not be evaluated. If executed outside a @testset, throw an exception  instead of returning Test.Fail or Test.Error.\n\nYou can use any L and R that work with the expanded expressions above (including  tuples, arrays, sets, dictionaries, strings, and more generable iterables). The ∅  symbol can also be used as shorthand for Set().\n\nThe only additional limitation is that setdiff(L, R) and intersect(L, R) must also work, since they are used to generate informative failure messages in some cases.\n\nSee also: Base.issetequal, Base.issubset, Base.isdisjoint, Base.setdiff,  Base.intersect.\n\nnote: Disjointness\nThe last form represents a slight abuse of notation, in that isdisjoint(L, R) is better notated as L ∩ R == ∅. The macro also supports this syntax, in addition  to shorthand L ∩ R and L || R.\n\nnote: Typing unicode characters\nUnicode operators can be typed in Julia editors by writing  \\<name><tab>. The ones supported by this macro are ≠ (\\neq),  ⊆ (\\subseteq), ⊇ (\\supseteq), ⊂ (\\subset), ⊃ (\\supset),  ⊊ (\\subsetneq), ⊋ (\\supsetneq), ∩ (\\cap), and ∅ (\\emptyset). \n\nExamples\n\njulia> @test_sets (1, 2) == (2, 1, 1, 1)\nTest Passed\n\njulia> @test_sets ∅ ⊆ 1:5\nTest Passed\n\njulia> @test_sets 1:3 ⊇ 5\nTest Failed at none:1\n  Expression: 1:3 ⊇ 5\n   Evaluated: L is not a superset of R.\n              R ∖ L has 1 element:  [5]\n\njulia> @test_sets [1, 2, 3] ∩ [2, 3, 4]\nTest Failed at none:1\n  Expression: [1, 2, 3] ∩ [2, 3, 4] == ∅\n   Evaluated: L and R are not disjoint.\n              L ∩ R has 2 elements: [2, 3]\n\njulia> @test_sets \"baabaa\" ≠ 'a':'b'\nTest Failed at none:1\n  Expression: \"baabaa\" ≠ 'a':'b'\n   Evaluated: L and R are equal.\n              L = R has 2 elements: ['b', 'a']\n\nThe macro supports broken=cond and skip=cond keywords, with similar behavior  to Test.@test:\n\nExamples\n\njulia> @test_sets [1] ⊆ [2, 3] broken=true\nTest Broken\n  Expression: [1] ⊆ [2, 3]\n\njulia> @test_sets [1] ⊆ [1, 2] broken=true\nError During Test at none:1\n Unexpected Pass\n Expression: [1] ⊆ [1, 2]\n Got correct result, please change to @test if no longer broken.\n\njulia> @test_sets [1] ⊆ [2, 3] skip=true\nTest Broken\n  Skipped: [1] ⊆ [2, 3]\n\n\n\n\n\n","category":"macro"},{"location":"reference/#PrettyTests.@test_all","page":"Reference","title":"PrettyTests.@test_all","text":"@test_all ex\n@test_all f(args...) key=val ...\n@test_all .!f(args...) key=val ...\n@test_all ex broken=true\n@test_all ex skip=true\n\nTest that the expression all(ex) evaluates to true. Unlike @test all(ex),  evaluation of ex will not short-circuit at the first false value, so that all elements that were false will be displayed in the failure message.\n\nIf executed inside a Test.@testset, return a Test.Pass result if all(ex) evaluates to true, a Test.Fail result if it is false or missing, and an Test.Error result if it  could not be evaluated. If executed outside a @testset, throw an exception instead of  returning Test.Fail or Test.Error.\n\nExamples\n\njulia> @test_all [1.0, 2.0] .== [1, 2]\nTest Passed\n\njulia> @test_all [1, 2, 3] .< 2\nTest Failed at none:1\n  Expression: all([1, 2, 3] .< 2)\n   Evaluated: false\n    Argument: 3-element BitVector, 2 failures:\n              [2]: 2 < 2 ===> false\n              [3]: 3 < 2 ===> false\n\nSimilar to @test, the @test_all f(args...) key=val... form is equivalent to writing @test_all f(args...; key=val...) which can be useful when the expression is a call using infix syntax such as vectorized approximate comparisons: \n\njulia> v = [0.99, 1.0, 1.01];\n\njulia> @test_all v .≈ 1 atol=0.1\nTest Passed\n\nThis is equivalent to the uglier test @test_all .≈(v, 1, atol=0.1).  Keyword splicing also works through any negation operator:\n\njulia> @test_all .!(v .≈ 1) atol=0.001\nTest Failed at none:1\n  Expression: all(.!.≈(v, 1, atol=0.001))\n   Evaluated: false\n    Argument: 3-element BitVector, 1 failure:\n              [2]: !≈(1.0, 1, atol=0.001) ===> false\n\n\nAs with @test, it is an error to supply more than one expression unless  the first is a call (possibly broadcast . syntax) and the rest are  assignments (k=v).\n\nThe macro supports broken=true and skip=true keywords, with similar behavior  to Test.@test:\n\njulia> @test_all [1, 2] .< 2 broken=true\nTest Broken\n  Expression: all([1, 2] .< 2)\n\njulia> @test_all [1, 2] .< 3 broken=true\nError During Test at none:1\n Unexpected Pass\n Expression: all([1, 2] .< 3)\n Got correct result, please change to @test if no longer broken.\n\njulia> @test_all [1, 2, 3] .< 2 skip=true\nTest Broken\n  Skipped: all([1, 2, 3] .< 2)\n\n\n\n\n\n","category":"macro"},{"location":"reference/#Display-settings","page":"Reference","title":"Display settings","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"PrettyTests.set_max_print_failures\nPrettyTests.disable_failure_styling\nPrettyTests.enable_failure_styling","category":"page"},{"location":"reference/#PrettyTests.set_max_print_failures","page":"Reference","title":"PrettyTests.set_max_print_failures","text":"set_max_print_failures(n=10)\n\nGlobaly sets the maximum number of individual failures that will be printed in a  failed @test_all test to n. If n is nothing, all failures are printed. If n == 0, only a summary is printed.\n\nBy default, if there are more than n=10 failing elements in a @test_all, the macro only shows messages for the first and last 5. Calling this function changes n globally for all subsequent tests, or until the function is called again.\n\nThe function returns the previous value of n so that it can be restored if desired.\n\nExamples\n\njulia> @test_all 1:3 .== 0\nTest Failed at none:1\n  Expression: all(1:3 .== 0)\n   Evaluated: false\n    Argument: 3-element BitVector, 3 failures:\n              [1]: 1 == 0 ===> false\n              [2]: 2 == 0 ===> false\n              [3]: 3 == 0 ===> false\n\njulia> set_max_print_failures(0);\n\njulia> @test_all 1:3 .== 0\nTest Failed at none:1\n  Expression: all(1:3 .== 0)\n   Evaluated: false\n    Argument: 3-element BitVector, 3 failures\n\n\n\n\n\n","category":"function"},{"location":"reference/#PrettyTests.disable_failure_styling","page":"Reference","title":"PrettyTests.disable_failure_styling","text":"disable_failure_styling()\n\nGlobally disable ANSI color styling in macro failure messages. \n\nAll tests macros that are run after this function will print failure messages  in plain text (or until enable_failure_styling() is called).\n\nThe function can be called when the module is loaded, e.g. in a runtests.jl file, to  disable styling throughout a test suite. Alternatively, it can be called at the beginning of a specific @testset and renabled at the end to disable styling for that specific test set.\n\nSee also enable_failure_styling.\n\n\n\n\n\n","category":"function"},{"location":"reference/#PrettyTests.enable_failure_styling","page":"Reference","title":"PrettyTests.enable_failure_styling","text":"enable_failure_styling()\n\nGlobally enable ANSI color styling in macro failure messages. \n\nAll test macros that are run after this function will print failure messages  with ANSI color styling for readability (or until disable_failure_styling() is called).\n\nSee also disable_failure_styling.\n\n\n\n\n\n","category":"function"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PrettyTests","category":"page"},{"location":"#Home","page":"Home","title":"Home","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This PrettyTests package extends Julia's basic unit-testing functionality by providing drop-in replacements for Test.@test with more informative, human-readable failure messages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"index.md\"]\nDepth = 2:3","category":"page"},{"location":"#@test_sets-for-set-like-comparisons","page":"Home","title":"@test_sets for set-like comparisons","text":"","category":"section"},{"location":"#Set-equality","page":"Home","title":"Set equality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The @test_sets macro functions as a drop-in replacement for @test when comparing two set-like objects. It accepts expressions of the form @test_sets L <op> R where op is an infix set comparison operator, and L and R are collections, broadly defined.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the simplest example, one could test for set equality with the (overloaded) == operator:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PrettyTests, Test \nPrettyTests.enable_failure_styling()\nPrettyTests.set_max_print_failures(10)\n\nmutable struct JustPrintTestSet <: Test.AbstractTestSet\n    results::Vector\n    JustPrintTestSet(desc) = new([])\nend\n\nfunction Test.record(ts::JustPrintTestSet, t::Test.Result)\n    str = sprint(show, t, context=:color=>true)\n    str = replace(str, r\"Stacktrace:(.|\\n)*$\" => \"Stacktrace: [...]\")\n    println(str)\n    push!(ts.results, t)\n    return t\nend\n\nTest.finish(ts::JustPrintTestSet) = nothing","category":"page"},{"location":"","page":"Home","title":"Home","text":"a, b = [2, 1, 1], [1, 2];\n@testset JustPrintTestSet begin # hide\n@test_sets a == b\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is equivalent to the uglier test @test issetequal(a, b). It is also more informative in the case of failure:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset JustPrintTestSet begin # hide\n@test_sets a == 2:4\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"The failed test message lists exactly how many and which elements were in the set differences L \\ R and R \\ L, which should have been empty in a passing test.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note how the collections interpreted as L and R are color-coded, so that they can be more easily identified if the expressions are long:","category":"page"},{"location":"","page":"Home","title":"Home","text":"variable_with_long_name = 1:3;\nfunction_with_long_name = () -> 4:9;\n@testset JustPrintTestSet begin # hide\n@test_sets variable_with_long_name ∪ Set(4:6) == function_with_long_name()\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Disable color output\nTo disable colored subexpressions in failure messages use disable_failure_styling().","category":"page"},{"location":"","page":"Home","title":"Home","text":"The symbol ∅ can be used as shorthand for Set() in the place of either L or R:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset JustPrintTestSet begin # hide\n@test_sets Set() == ∅\nend # hide\n\n@testset JustPrintTestSet begin # hide\n@test_sets Set(1) == ∅\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Because the macro internally expands the input expression to an issetequal call (and uses setdiff to print the differences), it works very flexibly with general collections, including sets, dictionaries, strings, etc:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset JustPrintTestSet begin # hide\n@test_sets Dict() == Set()\nend # hide\n\n@testset JustPrintTestSet begin # hide\n@test_sets \"baabaa\" == \"abc\"\nend # hide","category":"page"},{"location":"#Other-operators","page":"Home","title":"Other operators","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Other set comparison tests are also supported, with tailored failure messages. For example, the expression L ⊆ R is equivalent to issubset(L, R) (as it is in base Julia):","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset JustPrintTestSet begin # hide\n@test_sets \"baabaa\" ⊆ \"abc\"\nend # hide\n\n@testset JustPrintTestSet begin # hide\n@test_sets (3, 1, 2, 3) ⊆ (1, 2)\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note how, in this case, the failure displays only the set difference L \\ R and omits the irrelevant R \\ L.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The form L ∩ R == ∅ is equivalent to isdisjoint(L, R). In the case of failure, the macro displays the non-empty intersection L ∩ R, as computed by intersect:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset JustPrintTestSet begin # hide\n@test_sets (1, 2, 3) ∩ (4, 5, 6) == ∅\nend # hide\n\n@testset JustPrintTestSet begin # hide\n@test_sets \"baabaa\" ∩ \"abc\" == ∅\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Shorthand disjointness syntax\nThough slightly abusive in terms of notation, the macro will also accept L ∩ R and L || R as shorthands for isdisjoint(L, R):@testset JustPrintTestSet begin # hide\n@test_sets \"baabaa\" ∩ \"moooo\"\nend # hide\n@testset JustPrintTestSet begin # hide\n@test_sets (1,2) || (3,4)\nend # hide","category":"page"},{"location":"#@test_all-for-vectorized-tests","page":"Home","title":"@test_all for vectorized tests","text":"","category":"section"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The @test_all macro functions as a drop-in replacement for \"vectorized\" @tests. The name derives from the fact that @test_all ex will (mostly) behave like @test all(ex):","category":"page"},{"location":"","page":"Home","title":"Home","text":"using PrettyTests, Test \nPrettyTests.enable_failure_styling()\nPrettyTests.set_max_print_failures(10)\n\nmutable struct JustPrintTestSet <: Test.AbstractTestSet\n    results::Vector\n    JustPrintTestSet(desc) = new([])\nend\n\nfunction Test.record(ts::JustPrintTestSet, t::Test.Result)\n    str = sprint(show, t, context=:color=>true)\n    str = replace(str, r\"Stacktrace:(.|\\n)*$\" => \"Stacktrace: [...]\")\n    println(str)\n    push!(ts.results, t)\n    return t\nend\n\n#function Base.show(io::IO, t::Test.Fai)\n\nTest.finish(ts::JustPrintTestSet) = nothing","category":"page"},{"location":"","page":"Home","title":"Home","text":"a = [1, 2, 3, 4]; \n@testset JustPrintTestSet begin # hide\n@test all(a .< 5)\nend # hide\n@testset JustPrintTestSet begin # hide\n@test_all a .< 5\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"With one important difference: @test_all does not short-circuit when it encounters the first false value. It evaluates the full expression and checks that each element is not false, printing errors for each \"individual\" failure:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset JustPrintTestSet begin # hide\n@test_all a .< 2\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"The failure message can be parsed as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The expression all(a .< 2) evaluated to false\nThe argument to all() was a 4-element BitVector\nThere were 3 failures, i.e. elements of the argument that were false\nThese occured at indices [2], [3] and [4]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Like @test, the macro performed some introspection to show an unvectorized (and color-coded) form of the expression for each individual failure. For example, the failure at index [4] was because a[4] = 4, and 4 < 2 evaluated to false.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The introspection goes quite a bit deeper than what @test supports, handling pretty complicated expressions:","category":"page"},{"location":"","page":"Home","title":"Home","text":"x, y, str, func = 2, 4.0, \"baa\", arg -> arg > 0;\n@testset JustPrintTestSet begin # hide\n@test_all (x .< 2) .| isnan.(y) .& .!occursin.(r\"a|b\", str) .| func(-1)\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note also how, since ex evaluated to a scalar in this case, the failure message ommitted the summary/indexing and printed just the single failure under Argument:.","category":"page"},{"location":"","page":"Home","title":"Home","text":"info: Disable color output\nTo disable colored subexpressions in failure messages use disable_failure_styling().","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Why not `@testset` for ...?\nOne could achieve a similar effect to @test_all by using the @testset for built in to Test.  The test @test_all a .< 2 is basically equivalent to:@testset for i in eachindex(a)\n    @test a[i] < 2\nendWhile this syntax is more general, in cases where either form could be used @test_all offers some advantages:More compact syntax: obviates the need for the @testset for wrapper, as well as explicit indexing (e.g. a[i]) that can be left to broadcasting semantics.\nMore compact failure messaging: all relevant information about the indices and failure modes is given in a single Test.Fail result,  reducing redundant messages and print-outs from nested test sets.\nBetter readability: Deeper introspection and color-coding makes for more readable messages (see above).","category":"page"},{"location":"#Broadcasting-behavior","page":"Home","title":"Broadcasting behavior","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Expressions that involve more complicated broadcasting behaviour are also nicely formatted. If the expression evaluates to a higher-dimensional array (e.g. matrix), individual failures are identified by their CartesianIndex:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset JustPrintTestSet begin # hide\n@test_all [1 0] .== [1 0; 0 1]\nend # hide\n\n@testset JustPrintTestSet begin # hide\n@test_all occursin.([r\"a|b\" \"oo\"], [\"moo\", \"baa\"])\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"Ref can be used to avoid broadcasting certain elements:","category":"page"},{"location":"","page":"Home","title":"Home","text":"vals = [1,2,3];\n@testset JustPrintTestSet begin # hide\n@test_all 1:5 .∈ Ref(vals)\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"details: Introspection mechanics\nTo create individual failure messages, the @test_all parser recursively dives through the Abstract Syntax Tree (AST) of the input expression and creates/combines python-like format strings for any of the following \"displayable\" forms::comparisons or :calls with vectorized comparison operators, e.g. .==, .≈, .∈, etc.\n:calls to the vectorized negation operator .!\n:calls to vectorized bitwise logical operators, e.g. .&, .|, .⊻, .⊽\n:. (broadcast dot) calls to certain common functions, e.g. isnan, contains, occursin, etc.Any (sub-)expressions that do not fall into one of these categories are escaped and collectively broadcast, so that elements can splatted into the format string at each failing index.Note: Unvectorized forms are not considered displayable by the parser.  This is to avoid certain ambiguities with broadcasting under the current implementation. This may be changed in future.Example 1x, y = 2, 1;\n@testset JustPrintTestSet begin # hide\n@test_all (x .< y) .& (x < y)\nend # hideIn this example, the parser first receives the top-level expression (x .< y) .& (x < y), which it knows to display as $f1 & $f2 in unvectorized form.  The sub-format strings f1 and f2 must then be determined by recursively parsing  the expressions on either side of .&. On the left side, the sub-expression x .< y is also displayable as ($f11 < $f12) with format strings f11 and f22 given by further recursion. At this level, the  parser hits the base case, since neither x nor y are displayable forms. The two expressions are escaped and used as the first and second broadcast arguments, while the corresponding format strings {1:s} and {2:s} are passed back up the recursion to create f1 as ({1:s} < {2:s}).On the right side, x < y is not displayable (since it is unvectorized) and  therefore escaped as whole to make the third broadcasted argument. The corresponding format string {3:s} is passed back up the recursion, and used as f2.By the end, the parser has created the format string is ({1:s} < {2:s}) & {3:s},  with three corresponding expressions x, y, and x < y. Evaluating and collectively  broadcasting the latter results in the scalar 3-tuple (2, 1, false), which matches the dimension of the evaluated expression (false). Since this is a failure, the 3-tuple is splatted into the format string to create the part of the message that reads (2 < 1) & false.Example 2x, y = [5 6; 7 8], [5 6];\n@testset JustPrintTestSet begin # hide\n@test_all x .== y\nend # hideHere, the top-level expression x .== y is displayable, while the two sub-expressions x and y are not. The parser creates a format string {1:s} == {2:s} with  corresponding expressions x and y. After evaluating and broadcasting, the arguments create a 2×2 matrix of 2-tuples  to go with the 2×2 BitMatrix result. The latter has two false elements at indices [2,1] and [2,2], corresponding to the 2-tuples (7, 5) and (8, 6). Splatting each of these into the format string creates the parts of the message that read  7 == 5 and 8 == 6.","category":"page"},{"location":"#Keyword-splicing","page":"Home","title":"Keyword splicing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Like @test, @test_all will accept trailing keyword arguments that will be spliced into ex if it is a function call (possibly vectorized). This is primarily useful to make vectorized approximate comparisons more readable:","category":"page"},{"location":"","page":"Home","title":"Home","text":"v = [3, π, 4];\n@testset JustPrintTestSet begin # hide\n@test_all v .≈ 3.14 atol=0.01\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"As shown in the Expression: section, the trailing keyword atol was added to the .≈ call resulting in the test all(.≈(v, 3.14, atol=0.01)).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Splicing works with any callable function, including if it is wrapped in a negation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"ismod0 = (x; p=2) -> x % p == 0;\n@testset JustPrintTestSet begin # hide\n@test_all .!ismod0.(1:3) p = 3\nend # hide","category":"page"},{"location":"#General-iterables","page":"Home","title":"General iterables","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Paralleling its namesake, @test_all works with general iterables (as long as they also define length):","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct IsEven vals end\nBase.iterate(x::IsEven, i=1) = i > length(x.vals) ? nothing : (iseven(x.vals[i]), i+1);\nBase.length(x::IsEven) = length(x.vals)","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset JustPrintTestSet begin # hide\n@test_all IsEven(1:4)\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"If they also define keys and a corresponding getindex, failures will be printed by index:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Base.keys(x::IsEven) = keys(x.vals)\nBase.getindex(x::IsEven, args...) = getindex(x.vals, args...)","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset JustPrintTestSet begin # hide\n@test_all IsEven(1:4)\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Short-circuiting and iterables\nSince @test_all ex does not short-circuit at the first false value, it may behave differently than @test all(ex) in certain edge cases, notably when iterating over ex has side-effects.Consider the same IsEven iterable as above, but with an assertion that each value is non-negative:function Base.iterate(x::IsEven, i=1) \n    i > length(x.vals) && return nothing\n    @assert x.vals[i] >= 0\n    iseven(x.vals[i]), i+1\nend\nx = IsEven([1, 0, -1])\nnothing # hideEvaluating @test all(x) will return a Test.Fail, since the  evaluation of all(x) short-circuits after the first iteration and returns false:@testset JustPrintTestSet begin # hide\n@test all(x)\nend # hideConversely, @test_all x will return a Test.Error because it evaluates all iterations and thus triggers the assertion error on the third iteration:@testset JustPrintTestSet begin # hide\n@test_all x\nend # hide","category":"page"},{"location":"#Missing-values","page":"Home","title":"Missing values","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The only other major difference between @test all(ex) and @test_all ex is in how they deal with missing values. Recall that, in the presence of missing values, all() will return false if any non-missing value is false, or missing if all non-missing values are true.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Within an @test, the former will return a Test.Fail result, whereas the latter a Test.Error, pointing out that the return value was non-Boolean:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset JustPrintTestSet begin # hide\n@test all([1, missing] .== 2) # [false, missing] ===> false\nend # hide\n@testset JustPrintTestSet begin # hide\n@test all([2, missing] .== 2) # [true, missing] ===> missing\nend # hide","category":"page"},{"location":"","page":"Home","title":"Home","text":"In the respective cases, @test_all will show the result of evaluating all(ex) (false or missing), but always returns a Test.Fail result showing individual elements that were missing along with the ones that were false:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset JustPrintTestSet begin # hide\n@test_all [1, missing] .== 2\nend # hide\n@testset JustPrintTestSet begin # hide\n@test_all [2, missing] .== 2\nend # hide","category":"page"},{"location":"#Non-Boolean-values","page":"Home","title":"Non-Boolean values","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Finally, the macro will also produce a customized Test.Error result if the evaluated argument contains any non-Boolean, non-missing values. Where all() would short-circuit and throw a Core.TypeError on the first non-Boolean value, @test_all identifies the indices of all non-Boolean, non-missing values:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset JustPrintTestSet begin # hide\n@test_all [true, false, 42, \"a\", missing]\nend # hide","category":"page"},{"location":"#Test-integrations","page":"Home","title":"Test integrations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using PrettyTests, Test \nPrettyTests.enable_failure_styling()\nPrettyTests.set_max_print_failures(10)\n\nmutable struct JustPrintTestSet <: Test.AbstractTestSet\n    results::Vector\n    JustPrintTestSet(desc) = new([])\nend\n\nfunction Test.record(ts::JustPrintTestSet, t::Test.Result)\n    str = sprint(show, t, context=:color=>true)\n    str = replace(str, r\"Stacktrace:(.|\\n)*$\" => \"Stacktrace: [...]\")\n    println(str)\n    push!(ts.results, t)\n    return t\nend\n\nTest.finish(ts::JustPrintTestSet) = nothing","category":"page"},{"location":"","page":"Home","title":"Home","text":"A core feature of PrettyTests is that its macros integrate seamlessly with Julia's standard unit-testing framework. This stems primarily from the fact that they return one of the standard Test.Result objects defined therein, namely:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Test.Pass if the test expression evaluates to true\nTest.Fail if it evaluates to false (or missing in the case of @test_all)\nTest.Error if it cannot be evaluated.\nTest.Broken if the test is marked as broken.","category":"page"},{"location":"#Broken/skipped-tests","page":"Home","title":"Broken/skipped tests","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Both macros provide support for skip and broken keywords, with similar behavior to @test:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset JustPrintTestSet begin # hide\n@test_sets 1 ⊆ 2 skip=true\nend #hide\n@testset JustPrintTestSet begin # hide\n@test_all 1 .== 2 broken=true\nend #hide\n@testset JustPrintTestSet begin # hide\n@test_all 1 .== 1 broken=true\nend #hide","category":"page"},{"location":"#Working-with-@testset","page":"Home","title":"Working with @testset","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The macros also automatically run Test.record(Test.get_testset(), result) so that they play nicely with both built-in and user-defined AbstractTestSet types. In particular, they will register inside an @testset:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@testset \"MyTestSet\" begin\n    a = [1, 2]\n    @test_all a .== 1:2\n    @test_all a .< 1:2 broken=true\n    @test_sets a ⊆ 1:2\n    @test_sets a == 1:3 skip=true\nend;","category":"page"}]
}
